<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rugged Smart Construction Helmet - Demo</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #3a506b 0%, #1c2a38 100%); /* Deeper, industrial background */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #info {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.92); /* Even darker, more opaque */
            padding: 28px;
            border-radius: 18px;
            max-width: 380px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(8px); /* Stronger blur for modern look */
        }

        #info h2 {
            font-size: 2.1em; /* Larger title */
            margin-top: 0;
            border-bottom: 2px solid rgba(255,255,255,0.5);
            padding-bottom: 15px;
            margin-bottom: 20px;
            color: #98fb98; /* Light green for title */
            text-shadow: 0 0 10px rgba(152,251,152,0.6);
        }

        #info ul {
            list-style: none;
            padding: 0;
            margin: 18px 0;
        }

        #info ul li {
            margin-bottom: 10px;
            font-size: 1.05em;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            line-height: 1.4;
            color: #e0f8e0; /* Off-white for list items */
        }

        #info p {
            margin-top: 25px;
            font-size: 1em;
            color: #d0d0d0;
        }

        #controls {
            position: absolute;
            bottom: 25px;
            left: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.92);
            padding: 22px;
            border-radius: 18px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(8px);
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        #controls h3 {
            width: 100%;
            margin-top: 0;
            margin-bottom: 18px;
            color: #98fb98;
            font-size: 1.7em;
            border-bottom: 1px solid rgba(255,255,255,0.4);
            padding-bottom: 8px;
        }

        .control-button {
            background: linear-gradient(45deg, #4CAF50, #8BC34A); /* Green gradient */
            color: white;
            border: none;
            padding: 13px 22px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            box-shadow: 0 5px 12px rgba(0,0,0,0.4);
            font-weight: 600;
        }

        .control-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 18px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #388E3C, #689F38);
        }

        #status {
            position: absolute;
            top: 25px;
            right: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.92);
            padding: 28px;
            border-radius: 18px;
            max-width: 320px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(8px);
        }

        #status h3 {
            font-size: 1.7em;
            margin-top: 0;
            border-bottom: 2px solid rgba(255,255,255,0.4);
            padding-bottom: 12px;
            margin-bottom: 20px;
            color: #98fb98;
        }

        .status-item {
            margin: 18px 0;
            padding: 15px;
            border-radius: 10px;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 15px;
            font-weight: bold;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .status-disconnected {
            background: rgba(255, 60, 60, 0.3);
            border-left: 6px solid #ff3c3c;
        }

        .status-ready {
            background: rgba(255, 220, 0, 0.3);
            border-left: 6px solid #ffd000;
        }

        .status-connected {
            background: rgba(60, 255, 60, 0.3);
            border-left: 6px solid #3cff3c;
        }

        .led-indicator {
            width: 16px; 
            height: 16px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 10px rgba(255,255,255,0.7);
            animation: pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }

        .led-red { background: #ff0000; box-shadow: 0 0 12px #ff0000; }
        .led-yellow { background: #ffff00; box-shadow: 0 0 12px #ffff00; }
        .led-green { background: #00ff00; box-shadow: 0 0 12px #00ff00; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #3a506b 0%, #1c2a38 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.8em;
            color: white;
        }

        .spinner {
            border: 6px solid rgba(255,255,255,0.4);
            border-top: 6px solid white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .power-button {
            background: #e74c3c; /* Brighter red */
            color: white;
            border: none;
            padding: 18px 30px;
            margin-top: 15px;
            border-radius: 60px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 6px 18px rgba(231, 76, 60, 0.5);
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .power-button:hover {
            transform: scale(1.06) translateY(-3px);
            box-shadow: 0 10px 25px rgba(231, 76, 60, 0.7);
        }

        .power-button.on {
            background: #28a745; /* Bootstrap green */
            box-shadow: 0 6px 18px rgba(40, 167, 69, 0.5);
        }

        .power-button.on:hover {
            box-shadow: 0 10px 25px rgba(40, 167, 69, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Loading Smart Helmet 3D Model...</div>
        </div>

        <div id="info">
            <h2>üèóÔ∏è Smart Construction Helmet</h2>
            <p><strong>Integrated Technologies:</strong></p>
            <ul>
                <li>üìπ <strong>Ruggedized AI Camera</strong> - Real-time hazard detection & site monitoring.</li>
                <li>üö¶ <strong>Multi-Status LED</strong> - Instant operational feedback.</li>
                <li>üõ∞Ô∏è <strong>High-Precision GPS</strong> - Accurate location tracking & geofencing.</li>
                <li>üîã <strong>Extended-Life Smart Battery</strong> - All-day power with intelligent management.</li>
                <li>üîò <strong>Tactile Power Control</strong> - Durable, glove-friendly activation.</li>
                <li>üì° <strong>Industrial WiFi Module</strong> - Reliable site-wide connectivity for data transfer.</li>
            </ul>
            <p><strong>System Status Indicators:</strong></p>
            <div style="font-size: 0.9em; display: flex; flex-direction: column; gap: 8px; margin-top: 15px; color: #b0e0e6;">
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-red" style="animation: none; opacity: 1;"></span> **üî¥ Disconnected:** Helmet powered off or no network.</div>
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-yellow" style="animation: none; opacity: 1;"></span> **üü° Initializing:** Systems booting up, acquiring signals.</div>
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-green" style="animation: none; opacity: 1;"></span> **üü¢ Operational:** All systems online, recording & transmitting data.</div>
            </div>
        </div>

        <div id="controls">
            <h3>üéÆ Helmet Interaction</h3>
            <button class="control-button" onclick="toggleRotation()">‚è∏Ô∏è Pause/Resume Rotation</button>
            <button class="control-button" onclick="resetView()">üîÑ Reset Camera View</button>
            <button class="control-button" onclick="toggleWireframe()">üìê Toggle Wireframe Mode</button>
            <button class="power-button" id="powerBtn" onclick="togglePower()">üîå POWER OFF</button>
        </div>

        <div id="status">
            <h3>üìä Live Helmet Telemetry</h3>
            <div class="status-item status-disconnected" id="statusDisplay">
                <span class="led-indicator led-red"></span>
                <span>SYSTEM OFFLINE</span>
            </div>
            <div style="margin-top: 20px; font-size: 1em; color: #e0e0e0;">
                <div style="margin-bottom: 10px;"><strong>üõ∞Ô∏è GPS Status:</strong> <span id="gpsStatus">No Signal</span></div>
                <div style="margin-bottom: 10px;"><strong>üìπ Camera Feed:</strong> <span id="cameraStatus">Inactive</span></div>
                <div style="margin-bottom: 10px;"><strong>üîã Battery Level:</strong> <span id="batteryStatus">85% (Idle)</span></div>
                <div><strong>üì° Network Link:</strong> <span id="wifiStatus">Disconnected</span></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, helmet;
        let ledLight, gpsModule, batteryPack, powerButton; // Removed cameraHousing as it's now integrated
        let groundPlane; 
        let isRotating = true;
        let isWireframe = false;
        let isPoweredOn = false;
        let statusMode = 0; 

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111a2e); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 2, 4); // Adjust initial camera position
            camera.lookAt(0, 0.4, 0); // Point camera slightly lower to see the helmet better

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); 
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight1.position.set(5, 10, 5); 
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            directionalLight1.shadow.camera.near = 0.5;
            directionalLight1.shadow.camera.far = 50;
            directionalLight1.shadow.camera.left = -6;
            directionalLight1.shadow.camera.right = 6;
            directionalLight1.shadow.camera.top = 6;
            directionalLight1.shadow.camera.bottom = -6;
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xaaddff, 0.3); 
            directionalLight2.position.set(-5, 5, -8);
            scene.add(directionalLight2);

            const pointLight = new THREE.PointLight(0xadd8e6, 0.1); 
            pointLight.position.set(0, 0, 7);
            scene.add(pointLight);

            createGroundPlane();
            createHelmet();
            createComponents(); 
            createWiring(); 

            document.getElementById('loading').style.display = 'none';
            animate();
        }

        function createGroundPlane() {
            const planeRadius = 2.0; // Larger radius for more substantial ground
            const planeGeometry = new THREE.CircleGeometry(planeRadius, 64); 
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x222a3b, roughness: 0.9, metalness: 0.1 });
            groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            // The helmet's base will be at Y=0, so the ground plane should be there too
            groundPlane.position.y = 0; 
        }

        function createHelmet() {
            helmet = new THREE.Group();

            const helmetMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xE65100, // Deep industrial orange
                metalness: 0.1,
                roughness: 0.5,
                clearcoat: 0.8,
                clearcoatRoughness: 0.2,
                transparent: true,
                opacity: 0.98,
                side: THREE.FrontSide
            });

            // 1. Main Dome (a combination of shapes for the hard hat look)
            const topSphereRadius = 0.9;
            const topSphereGeometry = new THREE.SphereGeometry(topSphereRadius, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2); // Top half
            const topSphere = new THREE.Mesh(topSphereGeometry, helmetMaterial);
            topSphere.position.y = 0.2; // Move slightly up

            const lowerCylinderRadius = 1.0;
            const lowerCylinderHeight = 0.8;
            const lowerCylinderGeometry = new THREE.CylinderGeometry(lowerCylinderRadius, lowerCylinderRadius, lowerCylinderHeight, 64, 1, false, 0, Math.PI * 2);
            const lowerCylinder = new THREE.Mesh(lowerCylinderGeometry, helmetMaterial);
            lowerCylinder.position.y = -0.2; // Position to connect with sphere

            // Inner padding (defines thickness) - Create a slightly smaller version for the inside
            const innerPaddingMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444, 
                side: THREE.BackSide, 
                metalness: 0.1,
                roughness: 0.8
            });
            const innerTopSphere = new THREE.Mesh(new THREE.SphereGeometry(topSphereRadius * 0.9, 64, 32, 0, Math.PI * 2, 0, Math.PI / 2), innerPaddingMaterial);
            innerTopSphere.position.y = 0.15; // Slightly lower than outer topSphere

            const innerLowerCylinder = new THREE.Mesh(new THREE.CylinderGeometry(lowerCylinderRadius * 0.9, lowerCylinderRadius * 0.9, lowerCylinderHeight * 0.9, 64, 1, false, 0, Math.PI * 2), innerPaddingMaterial);
            innerLowerCylinder.position.y = -0.25; // Slightly lower than outer cylinder

            helmet.add(topSphere, lowerCylinder, innerTopSphere, innerLowerCylinder); // Add these parts to the helmet group


            // 2. Brim - more integrated, sharper, slightly downturned
            const brimShape = new THREE.Shape();
            brimShape.moveTo(-1.2, 0);
            brimShape.quadraticCurveTo(-1.3, -0.4, -0.6, -0.6);
            brimShape.lineTo(0.6, -0.6);
            brimShape.quadraticCurveTo(1.3, -0.4, 1.2, 0); // This creates the outer edge of the brim
            brimShape.lineTo(0.9, 0); // Inner point
            brimShape.quadraticCurveTo(1.0, -0.3, 0.5, -0.4);
            brimShape.lineTo(-0.5, -0.4);
            brimShape.quadraticCurveTo(-1.0, -0.3, -0.9, 0); // Inner edge of the brim, creating the hole
            
            const extrudeSettings = {
                steps: 1,
                depth: 0.1, // Brim thickness
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelOffset: 0,
                bevelSegments: 4
            };
            const brimGeometry = new THREE.ExtrudeGeometry(brimShape, extrudeSettings);
            const brimMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xBF360C, // Darker, more muted orange
                metalness: 0.1,
                roughness: 0.6,
                clearcoat: 0.6,
                clearcoatRoughness: 0.3
            });
            const brim = new THREE.Mesh(brimGeometry, brimMaterial);
            brim.rotation.x = -Math.PI / 2;
            brim.position.y = -0.5; // Position it below the helmet's main body
            brim.position.z = 1.0; // Bring it forward from the center of the helmet
            brim.scale.set(1.0, 1.2, 1.0); // Make it slightly elliptical for a more realistic brim shape
            brim.castShadow = true;
            helmet.add(brim);

            // 3. Chin Strap - simplified
            const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e, metalness: 0.1, roughness: 0.8 });
            const chinStrapGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.8, 8); // Simple cylinder for strap
            
            const strapL = new THREE.Mesh(chinStrapGeometry, strapMaterial);
            strapL.position.set(-0.7, -0.7, 0.5);
            strapL.rotation.z = Math.PI / 4;
            helmet.add(strapL);

            const strapR = new THREE.Mesh(chinStrapGeometry, strapMaterial);
            strapR.position.set(0.7, -0.7, 0.5);
            strapR.rotation.z = -Math.PI / 4;
            helmet.add(strapR);

            // Add subtle top ridges/vents (as part of helmet structure)
            const ridgeMaterial = new THREE.MeshStandardMaterial({ color: 0xF27036, metalness: 0.1, roughness: 0.5 });
            const ridgeHeight = 0.03;
            const ridgeRadius = 0.8; // Smaller radius for the ridges

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const x = ridgeRadius * Math.cos(angle);
                const z = ridgeRadius * Math.sin(angle);
                const ridgeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
                const ridge = new THREE.Mesh(ridgeGeometry, ridgeMaterial);
                ridge.position.set(x, 0.6 + ridgeHeight / 2, z); // Position on top of the dome
                ridge.rotation.y = angle;
                ridge.rotation.z = Math.PI / 2;
                helmet.add(ridge);
            }

            scene.add(helmet);
            
            // Adjust helmet position relative to ground plane
            // Lowest point of helmet after combining shapes is around -0.6 to -0.7 relative to its group center (Y=0)
            helmet.position.y = 0.65; // Lift the helmet so its lowest point rests on Y=0 of the ground plane
        }

        function createComponents() {
            // Camera Lens & LED integrated directly onto the helmet's front
            const cameraLensRadius = 0.08;
            const cameraLensDepth = 0.03;
            const cameraLensColor = 0x0a0a0a;

            // Main camera lens
            const lensGeometry = new THREE.CylinderGeometry(cameraLensRadius, cameraLensRadius, cameraLensDepth, 32);
            const lensMaterial = new THREE.MeshStandardMaterial({ color: cameraLensColor, metalness: 0.9, roughness: 0.1 });
            const cameraLens = new THREE.Mesh(lensGeometry, lensMaterial);
            cameraLens.rotation.x = Math.PI / 2;
            cameraLens.position.set(0, 0.0, 1.05); // Position directly on the helmet's front surface
            helmet.add(cameraLens);

            // Inner reflective part of the lens
            const innerLensGeometry = new THREE.CylinderGeometry(cameraLensRadius * 0.8, cameraLensRadius * 0.8, cameraLensDepth * 0.5, 32);
            const innerLensMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.95, roughness: 0.05, envMap: scene.environment });
            const innerLens = new THREE.Mesh(innerLensGeometry, innerLensMaterial);
            innerLens.position.z = cameraLensDepth * 0.5; // Slightly recessed
            cameraLens.add(innerLens); // Add to the main lens object

            // RGB LED Status Light - beside the camera lens
            const ledGeometry = new THREE.SphereGeometry(0.03, 16, 16); 
            const ledMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            ledLight = new THREE.Mesh(ledGeometry, ledMaterial);
            ledLight.position.set(0.18, 0.0, 1.0); // Position to the right of the lens
            helmet.add(ledLight); 

            // GPS Module (flatter, more integrated into top)
            const gpsGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.3); 
            const gpsMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50, metalness: 0.1, roughness: 0.5 }); 
            gpsModule = new THREE.Mesh(gpsGeometry, gpsMaterial);
            gpsModule.position.set(0, 0.95, 0); // Position on the flatter top of the helmet
            helmet.add(gpsModule);

            // GPS Antenna (sturdy, small)
            const antennaGeometry = new THREE.CylinderGeometry(0.007, 0.007, 0.15, 8); 
            const antennaMaterial = new THREE.MeshStandardMaterial({ color: 0x607d8b });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(0, 0.95 + 0.15 / 2 + 0.02, 0); // Above the GPS module
            helmet.add(antenna);

            // External Battery Pack (ruggedized, compact, at the very back base)
            const batteryGeometry = new THREE.BoxGeometry(0.5, 0.25, 0.2); 
            const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.6 }); 
            batteryPack = new THREE.Mesh(batteryGeometry, batteryMaterial);
            batteryPack.position.set(0, -0.6, -0.9); // Position at the lower back of the helmet
            batteryPack.castShadow = true;
            helmet.add(batteryPack);

            // Battery label recess
            const labelRecessGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.01);
            const labelRecessMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const labelRecess = new THREE.Mesh(labelRecessGeometry, labelRecessMaterial);
            labelRecess.position.set(0, 0, 0.101); 
            batteryPack.add(labelRecess);

            // Charging Port
            const chargePortGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16);
            const chargePortMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const chargePort = new THREE.Mesh(chargePortGeometry, chargePortMaterial);
            chargePort.position.set(0.15, -0.08, 0.1); 
            chargePort.rotation.x = Math.PI / 2;
            batteryPack.add(chargePort);

            // Power Button (Dedicated, on the other side of the helmet, lower and more accessible)
            const powerButtonHousingGeometry = new THREE.BoxGeometry(0.12, 0.35, 0.18); 
            const powerButtonHousingMaterial = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.7 });
            const powerButtonHousing = new THREE.Mesh(powerButtonHousingGeometry, powerButtonHousingMaterial);
            powerButtonHousing.position.set(-1.15, -0.3, 0.5); // Position on left side, lower, slightly forward
            powerButtonHousing.rotation.z = -Math.PI / 2; 
            helmet.add(powerButtonHousing);

            const buttonGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.08, 24); 
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xe74c3c, metalness: 0.1, roughness: 0.4 });
            powerButton = new THREE.Mesh(buttonGeometry, buttonMaterial); 
            powerButton.position.set(0, 0, 0.045); 
            powerButtonHousing.add(powerButton); 
        }

        function createWiring() {
            const conduitMaterial = new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.6 }); 
            const conduitRadius = 0.015; 

            // Wire from Camera to Battery (curved path, starts from camera lens position)
            // Note: Camera lens is now directly on helmet, so adjust start point
            const cameraConnectPoint = new THREE.Vector3(0.0, 0.0, 1.0); // A point near the camera on the helmet surface
            cameraConnectPoint.applyMatrix4(helmet.matrixWorld); // Transform to world space if needed, otherwise relative to helmet

            const batteryConnectPoint = new THREE.Vector3(batteryPack.position.x - 0.2, batteryPack.position.y + 0.05, batteryPack.position.z + 0.08);

            const curve1 = new THREE.CatmullRomCurve3([
                cameraConnectPoint.clone().sub(helmet.position), // Convert to helmet local space
                new THREE.Vector3(-0.4, -0.3, 0.8),
                new THREE.Vector3(-0.5, -0.4, -0.5),
                batteryConnectPoint.clone().sub(helmet.position) // Convert to helmet local space
            ]);
            const wireGeometry1 = new THREE.TubeGeometry(curve1, 64, conduitRadius, 8, false);
            const wire1 = new THREE.Mesh(wireGeometry1, conduitMaterial);
            helmet.add(wire1);

            // Wire from GPS to Battery (curved path, starts from GPS module position)
            const gpsConnectPoint = new THREE.Vector3(0, 0.9, 0); // Approximate center of GPS module
            const batteryConnectPoint2 = new THREE.Vector3(batteryPack.position.x + 0.2, batteryPack.position.y + 0.05, batteryPack.position.z + 0.08);
            
            const curve2 = new THREE.CatmullRomCurve3([
                gpsConnectPoint.clone().sub(helmet.position),
                new THREE.Vector3(0.5, 0.6, -0.2),
                new THREE.Vector3(0.3, 0.2, -0.8),
                batteryConnectPoint2.clone().sub(helmet.position)
            ]);
            const wireGeometry2 = new THREE.TubeGeometry(curve2, 64, conduitRadius, 8, false);
            const wire2 = new THREE.Mesh(wireGeometry2, conduitMaterial);
            helmet.add(wire2);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                helmet.rotation.y += 0.004; 
            }

            if (isPoweredOn) {
                const time = Date.now() * 0.003;
                ledLight.material.emissiveIntensity = Math.sin(time * 2) * 0.15 + 0.85; 
            } else {
                ledLight.material.emissiveIntensity = 0.15; 
            }

            renderer.render(scene, camera);
        }

        function togglePower() {
            isPoweredOn = !isPoweredOn;
            const powerBtnHTML = document.getElementById('powerBtn'); 

            const gpsStatus = document.getElementById('gpsStatus');
            const cameraStatus = document.getElementById('cameraStatus');
            const wifiStatus = document.getElementById('wifiStatus');
            const batteryStatus = document.getElementById('batteryStatus');

            if (isPoweredOn) {
                powerBtnHTML.textContent = 'üîå POWER ON';
                powerBtnHTML.classList.add('on');
                powerButton.material.color.setHex(0x28a745); 
                ledLight.material.emissiveIntensity = 0.5; 

                setTimeout(() => {
                    updateStatus(1); 
                    gpsStatus.textContent = 'Acquiring Signal...';
                    cameraStatus.textContent = 'Initializing AI...';
                    wifiStatus.textContent = 'Scanning Networks...';
                }, 800); 

                setTimeout(() => {
                    updateStatus(2); 
                    gpsStatus.textContent = 'GPS Locked (RTK Active)'; 
                    cameraStatus.textContent = 'Recording (AI Analyzing)'; 
                    wifiStatus.textContent = 'Connected to Site-Mesh Network'; 
                    batteryStatus.textContent = '80% (Active)'; 
                }, 2500); 

            } else {
                powerBtnHTML.textContent = 'üîå POWER OFF';
                powerBtnHTML.classList.remove('on');
                powerButton.material.color.setHex(0xe74c3c); 
                updateStatus(0); 
                gpsStatus.textContent = 'No Signal';
                cameraStatus.textContent = 'Inactive';
                wifiStatus.textContent = 'Disconnected';
                batteryStatus.textContent = '85% (Idle)'; 
            }
        }

        function updateStatus(mode) {
            statusMode = mode;
            const statusDisplay = document.getElementById('statusDisplay');

            switch(mode) {
                case 0: 
                    ledLight.material.color.setHex(0xff0000);
                    ledLight.material.emissive.setHex(0xff0000);
                    statusDisplay.className = 'status-item status-disconnected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-red"></span><span>SYSTEM OFFLINE</span>';
                    break;
                case 1: 
                    ledLight.material.color.setHex(0xffff00);
                    ledLight.material.emissive.setHex(0xffff00);
                    statusDisplay.className = 'status-item status-ready';
                    statusDisplay.innerHTML = '<span class="led-indicator led-yellow"></span><span>INITIALIZING SYSTEMS...</span>';
                    break;
                case 2: 
                    ledLight.material.color.setHex(0x00ff00);
                    ledLight.material.emissive.setHex(0x00ff00);
                    statusDisplay.className = 'status-item status-connected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-green"></span><span>OPERATIONAL & RECORDING</span>';
                    break;
            }
            ledLight.material.emissiveIntensity = isPoweredOn ? 0.85 : 0.15; 
        }

        function toggleRotation() {
            isRotating = !isRotating;
        }

        function resetView() {
            camera.position.set(2, 2, 4);
            helmet.rotation.set(0, 0, 0);
            isRotating = true; 
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            scene.traverse((object) => { 
                if (object.isMesh) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => { if (mat.wireframe !== undefined) mat.wireframe = isWireframe; });
                    } else {
                        if (object.material.wireframe !== undefined) object.material.wireframe = isWireframe;
                    }
                }
            });
        }

        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                helmet.rotation.y += deltaX * 0.005; 
                helmet.rotation.x += deltaY * 0.005;

                helmet.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, helmet.rotation.x));

                mouseX = event.clientX;
                mouseY = event.clientY;
                isRotating = false; 
            }
        });

        document.addEventListener('mousedown', (event) => {
            const targetElement = event.target;
            if (targetElement.closest('#info') || targetElement.closest('#controls') || targetElement.closest('#status')) {
                isMouseDown = false;
                return;
            }
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        let touchStartX = 0, touchStartY = 0;
        let touchLastX = 0, touchLastY = 0;

        document.addEventListener('touchstart', (event) => {
            const targetElement = event.target;
            if (targetElement.closest('#info') || targetElement.closest('#controls') || targetElement.closest('#status')) {
                return; 
            }
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                touchLastX = touchStartX;
                touchLastY = touchStartY;
                isRotating = false; 
            }
        }, { passive: false });

        document.addEventListener('touchmove', (event) => {
            if (event.touches.length === 1) {
                event.preventDefault(); 
                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const deltaX = currentX - touchLastX;
                const deltaY = currentY - touchLastY;

                helmet.rotation.y += deltaX * 0.005;
                helmet.rotation.x += deltaY * 0.005;

                helmet.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, helmet.rotation.x));

                touchLastX = currentX;
                touchLastY = currentY;
            }
        }, { passive: false });

        document.addEventListener('wheel', (event) => {
            event.preventDefault(); 
            camera.position.z += event.deltaY * 0.005; 
            camera.position.z = Math.max(2, Math.min(8, camera.position.z));
        }, { passive: false });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>