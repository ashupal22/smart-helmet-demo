
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Construction Helmet - Demo Model</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%); /* Deeper, more professional gradient */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #info {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.88); /* Slightly darker, more opaque */
            padding: 28px;
            border-radius: 18px;
            max-width: 380px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.25);
            backdrop-filter: blur(5px); /* Subtle blur effect */
        }

        #info h2 {
            font-size: 2em; /* Slightly larger title */
            margin-top: 0;
            border-bottom: 2px solid rgba(255,255,255,0.4);
            padding-bottom: 12px;
            margin-bottom: 20px;
            color: #87cefa; /* Sky blue for title */
            text-shadow: 0 0 8px rgba(135,206,250,0.5);
        }

        #info ul {
            list-style: none;
            padding: 0;
            margin: 18px 0;
        }

        #info ul li {
            margin-bottom: 10px;
            font-size: 1.05em; /* Slightly larger text */
            display: flex;
            align-items: flex-start; /* Align icon to top of text */
            gap: 12px;
            line-height: 1.4;
        }

        #info p {
            margin-top: 25px;
            font-size: 1em;
            color: #dcdcdc;
        }

        #controls {
            position: absolute;
            bottom: 25px;
            left: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.88);
            padding: 22px;
            border-radius: 18px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.25);
            backdrop-filter: blur(5px);
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
        }

        #controls h3 {
            width: 100%;
            margin-top: 0;
            margin-bottom: 18px;
            color: #87cefa;
            font-size: 1.6em;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 8px;
        }

        .control-button {
            background: linear-gradient(45deg, #5b86e5, #36d1dc); /* Blue-cyan gradient */
            color: white;
            border: none;
            padding: 13px 22px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
            box-shadow: 0 5px 12px rgba(0,0,0,0.4);
            font-weight: 600;
        }

        .control-button:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 18px rgba(0,0,0,0.6);
            background: linear-gradient(45deg, #4a77d1, #2cb0bd);
        }

        #status {
            position: absolute;
            top: 25px;
            right: 25px;
            z-index: 100;
            background: rgba(0,0,0,0.88);
            padding: 28px;
            border-radius: 18px;
            max-width: 320px;
            box-shadow: 0 10px 35px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.25);
            backdrop-filter: blur(5px);
        }

        #status h3 {
            font-size: 1.6em;
            margin-top: 0;
            border-bottom: 2px solid rgba(255,255,255,0.4);
            padding-bottom: 12px;
            margin-bottom: 20px;
            color: #87cefa;
        }

        .status-item {
            margin: 18px 0;
            padding: 15px;
            border-radius: 10px;
            font-size: 1em;
            display: flex;
            align-items: center;
            gap: 15px;
            font-weight: bold;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .status-disconnected {
            background: rgba(255, 60, 60, 0.25);
            border-left: 6px solid #ff3c3c;
        }

        .status-ready {
            background: rgba(255, 220, 0, 0.25);
            border-left: 6px solid #ffd000;
        }

        .status-connected {
            background: rgba(60, 255, 60, 0.25);
            border-left: 6px solid #3cff3c;
        }

        .led-indicator {
            width: 16px; /* Slightly larger LED */
            height: 16px;
            border-radius: 50%;
            display: inline-block;
            box-shadow: 0 0 10px rgba(255,255,255,0.6);
            animation: pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
        }

        .led-red { background: #ff0000; box-shadow: 0 0 12px #ff0000; }
        .led-yellow { background: #ffff00; box-shadow: 0 0 12px #ffff00; }
        .led-green { background: #00ff00; box-shadow: 0 0 12px #00ff00; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.9); }
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4b6cb7 0%, #182848 100%);
            z-index: 200;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 1.6em;
            color: white;
        }

        .spinner {
            border: 6px solid rgba(255,255,255,0.4);
            border-top: 6px solid white;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.5s linear infinite;
            margin-bottom: 30px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .power-button {
            background: #c0392b; /* Darker red for rugged feel */
            color: white;
            border: none;
            padding: 18px 30px;
            margin-top: 15px;
            border-radius: 60px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.2em;
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            box-shadow: 0 6px 18px rgba(192, 57, 43, 0.5);
            letter-spacing: 1.5px;
            text-transform: uppercase;
        }

        .power-button:hover {
            transform: scale(1.06) translateY(-3px);
            box-shadow: 0 10px 25px rgba(192, 57, 43, 0.7);
        }

        .power-button.on {
            background: #2ecc71; /* Brighter green when ON */
            box-shadow: 0 6px 18px rgba(46, 204, 113, 0.5);
        }

        .power-button.on:hover {
            box-shadow: 0 10px 25px rgba(46, 204, 113, 0.7);
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading">
            <div class="spinner"></div>
            <div>Loading Smart Helmet 3D Model...</div>
        </div>

        <div id="info">
            <h2>üèóÔ∏è Smart Construction Helmet</h2>
            <p><strong>Integrated Technologies:</strong></p>
            <ul>
                <li>üìπ <strong>Ruggedized AI Camera</strong> - Real-time hazard detection & site monitoring.</li>
                <li>üö¶ <strong>Multi-Status LED</strong> - Instant operational feedback.</li>
                <li>üõ∞Ô∏è <strong>High-Precision GPS</strong> - Accurate location tracking & geofencing.</li>
                <li>üîã <strong>Extended-Life Smart Battery</strong> - All-day power with intelligent management.</li>
                <li>üîò <strong>Tactile Power Control</strong> - Durable, glove-friendly activation.</li>
                <li>üì° <strong>Industrial WiFi Module</strong> - Reliable site-wide connectivity for data transfer.</li>
            </ul>
            <p><strong>System Status Indicators:</strong></p>
            <div style="font-size: 0.9em; display: flex; flex-direction: column; gap: 8px; margin-top: 15px; color: #b0e0e6;">
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-red" style="animation: none; opacity: 1;"></span> **üî¥ Disconnected:** Helmet powered off or no network.</div>
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-yellow" style="animation: none; opacity: 1;"></span> **üü° Initializing:** Systems booting up, acquiring signals.</div>
                <div style="display: flex; align-items: center; gap: 10px;"><span class="led-indicator led-green" style="animation: none; opacity: 1;"></span> **üü¢ Operational:** All systems online, recording & transmitting data.</div>
            </div>
        </div>

        <div id="controls">
            <h3>üéÆ Helmet Interaction</h3>
            <button class="control-button" onclick="toggleRotation()">‚è∏Ô∏è Pause/Resume Rotation</button>
            <button class="control-button" onclick="resetView()">üîÑ Reset Camera View</button>
            <button class="control-button" onclick="toggleWireframe()">üìê Toggle Wireframe Mode</button>
            <button class="power-button" id="powerBtn" onclick="togglePower()">üîå POWER OFF</button>
        </div>

        <div id="status">
            <h3>üìä Live Helmet Telemetry</h3>
            <div class="status-item status-disconnected" id="statusDisplay">
                <span class="led-indicator led-red"></span>
                <span>SYSTEM OFFLINE</span>
            </div>
            <div style="margin-top: 20px; font-size: 1em; color: #e0e0e0;">
                <div style="margin-bottom: 10px;"><strong>üõ∞Ô∏è GPS Status:</strong> <span id="gpsStatus">No Signal</span></div>
                <div style="margin-bottom: 10px;"><strong>üìπ Camera Feed:</strong> <span id="cameraStatus">Inactive</span></div>
                <div style="margin-bottom: 10px;"><strong>üîã Battery Level:</strong> <span id="batteryStatus">85% (Idle)</span></div>
                <div><strong>üì° Network Link:</strong> <span id="wifiStatus">Disconnected</span></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, helmet;
        let cameraHousing, ledLight, gpsModule, batteryPack, powerButtonHousing, powerButton; // Renamed powerButton to powerButtonHousing and added powerButton
        let groundPlane; // Reference to the ground plane
        let isRotating = true;
        let isWireframe = false;
        let isPoweredOn = false;
        let statusMode = 0; // 0: disconnected, 1: ready, 2: connected

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111a2e); 
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 2, 4);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.getElementById('container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); 
            scene.add(ambientLight);

            const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight1.position.set(5, 10, 5); 
            directionalLight1.castShadow = true;
            directionalLight1.shadow.mapSize.width = 2048;
            directionalLight1.shadow.mapSize.height = 2048;
            directionalLight1.shadow.camera.near = 0.5;
            directionalLight1.shadow.camera.far = 50;
            directionalLight1.shadow.camera.left = -6;
            directionalLight1.shadow.camera.right = 6;
            directionalLight1.shadow.camera.top = 6;
            directionalLight1.shadow.camera.bottom = -6;
            scene.add(directionalLight1);

            const directionalLight2 = new THREE.DirectionalLight(0xaaddff, 0.3); 
            directionalLight2.position.set(-5, 5, -8);
            scene.add(directionalLight2);

            const pointLight = new THREE.PointLight(0xadd8e6, 0.1); 
            pointLight.position.set(0, 0, 7);
            scene.add(pointLight);

            // Create ground plane
            createGroundPlane();

            // Create helmet and components
            createHelmet();
            createComponents();

            // Hide loading screen
            document.getElementById('loading').style.display = 'none';

            // Start animation
            animate();
        }

        function createGroundPlane() {
            const planeGeometry = new THREE.CircleGeometry(1.5, 64); // Circular plane
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x222a3b, roughness: 0.9, metalness: 0.1 });
            groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            groundPlane.receiveShadow = true;
            scene.add(groundPlane);
            
            // Position the ground plane precisely to align with the helmet's base
            // Based on helmetDome's lowest point (1.2 * (1 - cos(0.65*PI))) - 0.02 (padding offset) = ~ -0.99
            groundPlane.position.y = -1.0; 
        }

        function createHelmet() {
            helmet = new THREE.Group();

            // Main helmet dome - Robust, slightly thicker, industrial orange
            const helmetMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xE65100, // A deep, industrial orange
                metalness: 0.1,
                roughness: 0.5,
                clearcoat: 0.8, 
                clearcoatRoughness: 0.2,
                transparent: true,
                opacity: 0.98,
                side: THREE.FrontSide
            });
            const helmetDomeOuter = new THREE.Mesh(new THREE.SphereGeometry(1.2, 64, 32, 0, Math.PI * 2, 0, Math.PI * 0.65), helmetMaterial);
            helmetDomeOuter.castShadow = true;
            helmetDomeOuter.receiveShadow = true;
            helmet.add(helmetDomeOuter);

            // Inner padding/lining (defines the "thickness")
            const paddingGeometry = new THREE.SphereGeometry(1.1, 64, 32, 0, Math.PI * 2, 0, Math.PI * 0.62); 
            const paddingMaterial = new THREE.MeshStandardMaterial({
                color: 0x444444, 
                side: THREE.BackSide, 
                metalness: 0.1,
                roughness: 0.8
            });
            const padding = new THREE.Mesh(paddingGeometry, paddingMaterial);
            padding.position.y = -0.02; 
            helmet.add(padding);

            // Helmet brim - slightly darker orange, more pronounced
            const brimGeometry = new THREE.RingGeometry(1.2, 1.55, 64, 1, 0, Math.PI * 0.7); 
            const brimMaterial = new THREE.MeshPhysicalMaterial({
                color: 0xBF360C, 
                side: THREE.DoubleSide,
                metalness: 0.1,
                roughness: 0.6,
                clearcoat: 0.6,
                clearcoatRoughness: 0.3
            });
            const brim = new THREE.Mesh(brimGeometry, brimMaterial);
            brim.rotation.x = -Math.PI / 2;
            brim.position.y = -0.42; 
            brim.position.z = 0.55; 
            brim.castShadow = true;
            helmet.add(brim);

            // Helmet chin straps - Integrated to look connected, not floating
            const strapMaterial = new THREE.MeshStandardMaterial({ color: 0x34495e, metalness: 0.1, roughness: 0.8 });
            
            // Left strap (connects to helmet and goes down)
            const curveStrap1 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0.9, -0.2, 0.4), // Start near helmet side
                new THREE.Vector3(0.7, -0.7, 0.2), // Bend outwards
                new THREE.Vector3(0.5, -1.2, 0)  // Go downwards
            ]);
            const strapGeometry1 = new THREE.TubeGeometry(curveStrap1, 32, 0.025, 8, false);
            const strap1 = new THREE.Mesh(strapGeometry1, strapMaterial);
            helmet.add(strap1);

            // Right strap
            const curveStrap2 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(-0.9, -0.2, 0.4), // Start near helmet side
                new THREE.Vector3(-0.7, -0.7, 0.2), // Bend outwards
                new THREE.Vector3(-0.5, -1.2, 0) // Go downwards
            ]);
            const strapGeometry2 = new THREE.TubeGeometry(curveStrap2, 32, 0.025, 8, false);
            const strap2 = new THREE.Mesh(strapGeometry2, strapMaterial);
            helmet.add(strap2);

            // Add subtle top ridges/vents for robustness (these are part of the helmet structure, not floating)
            const ridgeMaterial = new THREE.MeshStandardMaterial({ color: 0xF27036, metalness: 0.1, roughness: 0.5 });
            const ridgeHeight = 0.03;
            const ridgeRadius = 1.1;

            for (let i = 0; i < 4; i++) {
                const angle = i * Math.PI / 2;
                const x = ridgeRadius * Math.cos(angle);
                const z = ridgeRadius * Math.sin(angle);
                const ridgeGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
                const ridge = new THREE.Mesh(ridgeGeometry, ridgeMaterial);
                ridge.position.set(x, 1.1 + ridgeHeight / 2, z); 
                ridge.rotation.y = angle;
                ridge.rotation.z = Math.PI / 2;
                helmet.add(ridge);
            }

            scene.add(helmet);
            
            // Adjust helmet position relative to ground plane
            helmet.position.y = 0.4; // Lift helmet slightly to sit on the plane
        }

        function createComponents() {
            // Camera Housing (black box) - THINNER and INTEGRATED
            const cameraHousingGeometry = new THREE.BoxGeometry(0.6, 0.25, 0.15); // Width, Height, Thickness
            const cameraHousingMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.2, roughness: 0.6 });
            cameraHousing = new THREE.Mesh(cameraHousingGeometry, cameraHousingMaterial);
            cameraHousing.position.set(0, 0.05, 1.25); // Positioned forward on the helmet
            cameraHousing.castShadow = true;
            helmet.add(cameraHousing);

            // Camera Lens (more prominent, centered in housing)
            const lensOuterGeometry = new THREE.CylinderGeometry(0.09, 0.09, 0.07, 32); 
            const lensOuterMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a0a, metalness: 0.9, roughness: 0.1 });
            const lensOuter = new THREE.Mesh(lensOuterGeometry, lensOuterMaterial);
            lensOuter.position.set(0, 0, 0.07); // Position relative to cameraHousing (front face)
            lensOuter.rotation.x = Math.PI / 2;
            cameraHousing.add(lensOuter); 

            const lensInnerGeometry = new THREE.CylinderGeometry(0.07, 0.07, 0.03, 32); 
            const lensInnerMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, metalness: 0.95, roughness: 0.05, envMap: scene.environment }); 
            const lensInner = new THREE.Mesh(lensInnerGeometry, lensInnerMaterial);
            lensInner.position.z = 0.02; 
            lensOuter.add(lensInner); 

            // RGB LED Status Light - BESIDE the camera lens on the housing
            const ledGeometry = new THREE.SphereGeometry(0.04, 16, 16); 
            const ledMaterial = new THREE.MeshPhongMaterial({
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            ledLight = new THREE.Mesh(ledGeometry, ledMaterial);
            ledLight.position.set(0.2, 0, 0.07); // Position relative to cameraHousing (to the right of lens)
            cameraHousing.add(ledLight); 

            // GPS Module (flatter, more integrated into top)
            const gpsGeometry = new THREE.BoxGeometry(0.3, 0.05, 0.3); 
            const gpsMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50, metalness: 0.1, roughness: 0.5 }); 
            gpsModule = new THREE.Mesh(gpsGeometry, gpsMaterial);
            gpsModule.position.set(0, 1.05, 0); 
            helmet.add(gpsModule);

            // GPS Antenna (sturdy, small)
            const antennaGeometry = new THREE.CylinderGeometry(0.007, 0.007, 0.15, 8); 
            const antennaMaterial = new THREE.MeshStandardMaterial({ color: 0x607d8b });
            const antenna = new THREE.Mesh(antennaGeometry, antennaMaterial);
            antenna.position.set(0, 1.15, 0); 
            helmet.add(antenna);

            // External Battery Pack (ruggedized, compact)
            const batteryGeometry = new THREE.BoxGeometry(0.5, 0.25, 0.2); 
            const batteryMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.2, roughness: 0.6 }); 
            batteryPack = new THREE.Mesh(batteryGeometry, batteryMaterial);
            batteryPack.position.set(0, -0.15, -1.35); 
            batteryPack.castShadow = true;
            helmet.add(batteryPack);

            // Battery label recess
            const labelRecessGeometry = new THREE.BoxGeometry(0.3, 0.1, 0.01);
            const labelRecessMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
            const labelRecess = new THREE.Mesh(labelRecessGeometry, labelRecessMaterial);
            labelRecess.position.set(0, 0, 0.101); 
            batteryPack.add(labelRecess);

            // Charging Port
            const chargePortGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.02, 16);
            const chargePortMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.8 });
            const chargePort = new THREE.Mesh(chargePortGeometry, chargePortMaterial);
            chargePort.position.set(0.15, -0.08, 0.1); 
            chargePort.rotation.x = Math.PI / 2;
            batteryPack.add(chargePort);

            // Power Button (on the other side of the helmet, not on the camera housing)
            const buttonHousingGeometry = new THREE.BoxGeometry(0.1, 0.3, 0.15); // A small base for the button
            const buttonHousingMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7 });
            powerButtonHousing = new THREE.Mesh(buttonHousingGeometry, buttonHousingMaterial); // Store reference
            powerButtonHousing.position.set(-1.2, 0.2, 0); // Positioned on the left side (opposite to original)
            powerButtonHousing.rotation.z = -Math.PI / 2; // Rotate for left side
            helmet.add(powerButtonHousing);

            const buttonGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.08, 24); 
            const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0xc0392b, metalness: 0.1, roughness: 0.4 });
            powerButton = new THREE.Mesh(buttonGeometry, buttonMaterial); // Store reference
            powerButton.position.set(0, 0, 0.04); // Protruding from housing
            powerButtonHousing.add(powerButton); // Add to its housing

            // Wiring between components - now as armored conduits
            createWiring();
        }

        function createWiring() {
            const conduitMaterial = new THREE.MeshStandardMaterial({ color: 0x5a5a5a, roughness: 0.6 }); 
            const conduitRadius = 0.015; 

            // Wire from camera housing to battery (curved path)
            const curve1 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(cameraHousing.position.x - 0.2, cameraHousing.position.y - 0.05, cameraHousing.position.z), 
                new THREE.Vector3(-0.4, -0.3, 0.8),
                new THREE.Vector3(-0.5, -0.4, -0.5),
                new THREE.Vector3(batteryPack.position.x - 0.2, batteryPack.position.y + 0.05, batteryPack.position.z + 0.08) 
            ]);
            const wireGeometry1 = new THREE.TubeGeometry(curve1, 64, conduitRadius, 8, false);
            const wire1 = new THREE.Mesh(wireGeometry1, conduitMaterial);
            helmet.add(wire1);

            // Wire from GPS to battery (curved path)
            const curve2 = new THREE.CatmullRomCurve3([
                new THREE.Vector3(gpsModule.position.x, gpsModule.position.y - 0.03, gpsModule.position.z), 
                new THREE.Vector3(0.5, 0.6, -0.2),
                new THREE.Vector3(0.3, 0.2, -0.8),
                new THREE.Vector3(batteryPack.position.x + 0.2, batteryPack.position.y + 0.05, batteryPack.position.z + 0.08) 
            ]);
            const wireGeometry2 = new THREE.TubeGeometry(curve2, 64, conduitRadius, 8, false);
            const wire2 = new THREE.Mesh(wireGeometry2, conduitMaterial);
            helmet.add(wire2);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (isRotating) {
                helmet.rotation.y += 0.004; 
            }

            // Animate LED based on status
            if (isPoweredOn) {
                const time = Date.now() * 0.003;
                ledLight.material.emissiveIntensity = Math.sin(time * 2) * 0.15 + 0.85; 
            } else {
                ledLight.material.emissiveIntensity = 0.15; 
            }

            renderer.render(scene, camera);
        }

        function togglePower() {
            isPoweredOn = !isPoweredOn;
            const powerBtnHTML = document.getElementById('powerBtn'); // Reference to the HTML button

            const gpsStatus = document.getElementById('gpsStatus');
            const cameraStatus = document.getElementById('cameraStatus');
            const wifiStatus = document.getElementById('wifiStatus');
            const batteryStatus = document.getElementById('batteryStatus');

            if (isPoweredOn) {
                powerBtnHTML.textContent = 'üîå POWER ON';
                powerBtnHTML.classList.add('on');
                powerButton.material.color.setHex(0x2ecc71); // 3D button green color
                ledLight.material.emissiveIntensity = 0.5; 

                setTimeout(() => {
                    updateStatus(1); 
                    gpsStatus.textContent = 'Acquiring Signal...';
                    cameraStatus.textContent = 'Initializing AI...';
                    wifiStatus.textContent = 'Scanning Networks...';
                }, 800); 

                setTimeout(() => {
                    updateStatus(2); 
                    gpsStatus.textContent = 'GPS Locked (RTK Active)'; 
                    cameraStatus.textContent = 'Recording (AI Analyzing)'; 
                    wifiStatus.textContent = 'Connected to Site-Mesh Network'; 
                    batteryStatus.textContent = '80% (Active)'; 
                }, 2500); 

            } else {
                powerBtnHTML.textContent = 'üîå POWER OFF';
                powerBtnHTML.classList.remove('on');
                powerButton.material.color.setHex(0xc0392b); // 3D button red color
                updateStatus(0); 
                gpsStatus.textContent = 'No Signal';
                cameraStatus.textContent = 'Inactive';
                wifiStatus.textContent = 'Disconnected';
                batteryStatus.textContent = '85% (Idle)'; 
            }
        }

        function updateStatus(mode) {
            statusMode = mode;
            const statusDisplay = document.getElementById('statusDisplay');

            switch(mode) {
                case 0: // Disconnected - Red
                    ledLight.material.color.setHex(0xff0000);
                    ledLight.material.emissive.setHex(0xff0000);
                    statusDisplay.className = 'status-item status-disconnected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-red"></span><span>SYSTEM OFFLINE</span>';
                    break;
                case 1: // Ready - Yellow
                    ledLight.material.color.setHex(0xffff00);
                    ledLight.material.emissive.setHex(0xffff00);
                    statusDisplay.className = 'status-item status-ready';
                    statusDisplay.innerHTML = '<span class="led-indicator led-yellow"></span><span>INITIALIZING SYSTEMS...</span>';
                    break;
                case 2: // Connected - Green
                    ledLight.material.color.setHex(0x00ff00);
                    ledLight.material.emissive.setHex(0x00ff00);
                    statusDisplay.className = 'status-item status-connected';
                    statusDisplay.innerHTML = '<span class="led-indicator led-green"></span><span>OPERATIONAL & RECORDING</span>';
                    break;
            }
            ledLight.material.emissiveIntensity = isPoweredOn ? 0.85 : 0.15; 
        }

        function toggleRotation() {
            isRotating = !isRotating;
        }

        function resetView() {
            camera.position.set(2, 2, 4);
            helmet.rotation.set(0, 0, 0);
            isRotating = true; 
        }

        function toggleWireframe() {
            isWireframe = !isWireframe;
            scene.traverse((object) => { 
                if (object.isMesh) {
                    if (Array.isArray(object.material)) {
                        object.material.forEach(mat => { if (mat.wireframe !== undefined) mat.wireframe = isWireframe; });
                    } else {
                        if (object.material.wireframe !== undefined) object.material.wireframe = isWireframe;
                    }
                }
            });
        }

        // Mouse controls for rotation
        let mouseX = 0, mouseY = 0;
        let isMouseDown = false;

        document.addEventListener('mousemove', (event) => {
            if (isMouseDown) {
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;

                helmet.rotation.y += deltaX * 0.005; 
                helmet.rotation.x += deltaY * 0.005;

                helmet.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, helmet.rotation.x));

                mouseX = event.clientX;
                mouseY = event.clientY;
                isRotating = false; 
            }
        });

        document.addEventListener('mousedown', (event) => {
            const targetElement = event.target;
            if (targetElement.closest('#info') || targetElement.closest('#controls') || targetElement.closest('#status')) {
                isMouseDown = false;
                return;
            }
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Touch controls for mobile
        let touchStartX = 0, touchStartY = 0;
        let touchLastX = 0, touchLastY = 0;

        document.addEventListener('touchstart', (event) => {
            const targetElement = event.target;
            if (targetElement.closest('#info') || targetElement.closest('#controls') || targetElement.closest('#status')) {
                return; 
            }
            if (event.touches.length === 1) {
                touchStartX = event.touches[0].clientX;
                touchStartY = event.touches[0].clientY;
                touchLastX = touchStartX;
                touchLastY = touchStartY;
                isRotating = false; 
            }
        }, { passive: false });

        document.addEventListener('touchmove', (event) => {
            if (event.touches.length === 1) {
                event.preventDefault(); 
                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;

                const deltaX = currentX - touchLastX;
                const deltaY = currentY - touchLastY;

                helmet.rotation.y += deltaX * 0.005;
                helmet.rotation.x += deltaY * 0.005;

                helmet.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, helmet.rotation.x));

                touchLastX = currentX;
                touchLastY = currentY;
            }
        }, { passive: false });

        // Zoom with mouse wheel
        document.addEventListener('wheel', (event) => {
            event.preventDefault(); 
            camera.position.z += event.deltaY * 0.005; 
            camera.position.z = Math.max(2, Math.min(8, camera.position.z));
        }, { passive: false });


        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize the scene
        init();
    </script>
</body>
</html>
```